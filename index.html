<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio File Enhancer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for better aesthetics and mobile usability */
        :root {
            --primary-color: #f59e0b; /* Tailwind amber-500 */
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        .container-card {
            background-color: white;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            border-radius: 1rem;
            padding: 1.5rem;
            max-width: 90%;
            margin: 2rem auto;
            transition: all 0.3s ease;
        }
        /* Style for the range input tracks */
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: #e5e7eb;
            border-radius: 4px;
            margin: 8px 0;
            cursor: pointer;
        }
        /* Style for the range input thumbs */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            transition: background 0.2s ease;
        }
        input[type="range"]:focus {
            outline: none;
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <div class="container-card">
        <h1 class="text-3xl font-extrabold text-gray-900 mb-2 flex items-center">
            <svg class="w-8 h-8 mr-2 text-amber-500" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM7 9a1 1 0 000 2h6a1 1 0 100-2H7z" clip-rule="evenodd"></path></svg>
            Audio File Enhancer
        </h1>
        <p class="text-gray-500 mb-6">Upload an audio file (voice or music) to apply **Compression, EQ, and Reverb**, then play or download the enhanced version.</p>

        <!-- File Input Area -->
        <div class="mb-6 space-y-3">
            <label for="audioFile" class="block text-sm font-medium text-gray-700">Select Audio File (MP3, WAV, etc.)</label>
            <input type="file" id="audioFile" accept="audio/*" class="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-amber-50 file:text-amber-700 hover:file:bg-amber-100 cursor-pointer">
        </div>

        <!-- Status Area -->
        <div id="status-box" class="p-3 mb-6 rounded-lg text-sm transition-colors duration-300 bg-gray-100 text-gray-700">
            Awaiting file selection...
        </div>

        <!-- Play/Stop and Download Buttons -->
        <div class="flex space-x-4">
            <button id="toggleButton" disabled class="flex-1 py-3 px-6 text-xl font-bold rounded-xl shadow-lg transition-all duration-200 focus:outline-none focus:ring-4 focus:ring-amber-300 bg-amber-500 text-white opacity-50 cursor-not-allowed active:scale-[0.99] disabled:opacity-50">
                Play Enhanced Audio
            </button>
            <button id="downloadButton" disabled class="w-1/3 py-3 px-6 text-lg font-bold rounded-xl shadow-lg transition-all duration-200 focus:outline-none focus:ring-4 focus:ring-sky-300 bg-sky-500 text-white opacity-50 cursor-not-allowed active:scale-[0.99] disabled:opacity-50">
                Download WAV
            </button>
        </div>
        <p id="fileNameDisplay" class="text-sm text-center text-gray-500 mt-2 italic hidden"></p>


        <!-- Enhancement Controls -->
        <div id="controls" class="mt-8 space-y-6 opacity-50 pointer-events-none transition-opacity duration-300">
            <h2 class="text-xl font-semibold text-gray-800 border-b pb-2 mb-4">Enhancement Settings</h2>
            
            <!-- Compression Threshold -->
            <div class="control-group">
                <label for="compressionThreshold" class="block text-sm font-medium text-gray-700 mb-1">Compression Threshold (<span id="compressionThresholdValue">-24 dB</span>)</label>
                <input type="range" id="compressionThreshold" min="-60" max="0" value="-24" step="0.5">
                <p class="text-xs text-gray-400 mt-1">Sets the level at which compression starts. Lower (more negative) means more leveling and a richer sound.</p>
            </div>
            
            <!-- Reverb Depth Control (NEW) -->
            <div class="control-group">
                <label for="reverbDepth" class="block text-sm font-medium text-gray-700 mb-1">Reverb Depth (Wet/Dry Mix) (<span id="reverbDepthValue">0%</span>)</label>
                <input type="range" id="reverbDepth" min="0" max="100" value="0" step="1">
                <p class="text-xs text-gray-400 mt-1">Controls the amount of simulated room reverb mixed into the sound.</p>
            </div>

            <!-- Warmth/Bass Boost (Low-Shelf Filter) -->
            <div class="control-group">
                <label for="warmthBoost" class="block text-sm font-medium text-gray-700 mb-1">Warmth/Bass Boost (Low-Shelf Gain) (<span id="warmthBoostValue">0 dB</span>)</label>
                <input type="range" id="warmthBoost" min="-12" max="12" value="0" step="0.1">
                <p class="text-xs text-gray-400 mt-1">Boosts low frequencies (below 250Hz) for warmth and body, ideal for music and deep voices.</p>
            </div>

            <!-- Clarity Boost (High-Shelf Filter) -->
            <div class="control-group">
                <label for="clarityBoost" class="block text-sm font-medium text-gray-700 mb-1">Clarity Boost (High-Shelf Gain) (<span id="clarityBoostValue">0 dB</span>)</label>
                <input type="range" id="clarityBoost" min="-12" max="12" value="0" step="0.1">
                <p class="text-xs text-gray-400 mt-1">Boosts high frequencies (above 3kHz) for vocal clarity or musical sparkle.</p>
            </div>

            <!-- Output Volume Control -->
            <div class="control-group">
                <label for="masterGain" class="block text-sm font-medium text-gray-700 mb-1">Output Volume (<span id="masterGainValue">1.0</span>)</label>
                <input type="range" id="masterGain" min="0" max="2" value="1.0" step="0.05">
                <p class="text-xs text-gray-400 mt-1">Controls the final playback volume.</p>
            </div>
        </div>
    </div>

    <script type="module">
        // --- Firebase/Authentication Compliance (Standard Setup) ---
        // Boilerplate required for the Canvas environment, though not used for audio processing.
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";

        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        if (firebaseConfig) {
            const app = initializeApp(firebaseConfig);
            const auth = getAuth(app);

            async function authenticate() {
                try {
                    if (initialAuthToken) {
                        await signInWithCustomToken(auth, initialAuthToken);
                    } else {
                        await signInAnonymously(auth);
                    }
                    console.log("Firebase authentication successful.");
                } catch (error) {
                    console.error("Firebase authentication failed:", error);
                }
            }
            authenticate();
        }
        // -----------------------------------------------------------

        // --- Web Audio API Logic ---
        let audioContext;
        let audioBuffer; // Holds the decoded ORIGINAL audio data
        let sourceNode; // The node that plays the audioBuffer
        let compressor;
        let lowShelfFilter;
        let highShelfFilter;
        let convolver; // NEW: ConvolverNode for Reverb
        let dryGain;   // NEW: Gain node for the clean signal
        let wetGain;   // NEW: Gain node for the reverberated signal
        let masterGain;
        let impulseResponseBuffer; // The self-generated IR buffer

        let isPlaying = false;
        let startTime = 0;
        let elapsed = 0;
        let uploadedFileName = 'enhanced_audio';

        const fileInput = document.getElementById('audioFile');
        const toggleButton = document.getElementById('toggleButton');
        const downloadButton = document.getElementById('downloadButton');
        const statusBox = document.getElementById('status-box');
        const controlsDiv = document.getElementById('controls');
        const fileNameDisplay = document.getElementById('fileNameDisplay');

        // Control elements
        const masterGainInput = document.getElementById('masterGain');
        const masterGainValueSpan = document.getElementById('masterGainValue');
        const clarityBoostInput = document.getElementById('clarityBoost');
        const clarityBoostValueSpan = document.getElementById('clarityBoostValue');
        const compressionThresholdInput = document.getElementById('compressionThreshold');
        const compressionThresholdValueSpan = document.getElementById('compressionThresholdValue');
        const warmthBoostInput = document.getElementById('warmthBoost');
        const warmthBoostValueSpan = document.getElementById('warmthBoostValue');
        
        // NEW Control element
        const reverbDepthInput = document.getElementById('reverbDepth');
        const reverbDepthValueSpan = document.getElementById('reverbDepthValue');


        /**
         * Creates a simple, synthetic impulse response buffer (decaying noise).
         * This simulates a basic room reverb effect.
         * @param {AudioContext|OfflineAudioContext} context The audio context.
         * @returns {AudioBuffer} The generated impulse response.
         */
        function createImpulseResponse(context) {
            const duration = 2.0; // 2 seconds reverb tail
            const decay = 3.0;    // Exponential decay factor
            const sampleRate = context.sampleRate;
            const length = sampleRate * duration;
            const impulse = context.createBuffer(2, length, sampleRate); // Stereo buffer
            
            for (let c = 0; c < 2; c++) {
                const channel = impulse.getChannelData(c);
                for (let i = 0; i < length; i++) {
                    let noise = Math.random() * 2 - 1;
                    let envelope = Math.pow(1 - (i / length), decay);
                    // Add a tiny bit of high-frequency attenuation for realism
                    if (i > length * 0.5) {
                        envelope *= 0.98;
                    }
                    channel[i] = noise * envelope;
                }
            }
            return impulse;
        }

        /**
         * Initializes the Web Audio context and enhancement nodes.
         * Chain: Source -> Compressor -> LowShelf -> HighShelf -> [SPLIT]
         * SPLIT Path 1 (Dry): -> DryGain -> MasterGain
         * SPLIT Path 2 (Wet): -> Convolver -> WetGain -> MasterGain
         * @param {AudioContext|OfflineAudioContext} context The audio context to use
         * @returns {AudioNode} The input node of the enhancement chain (compressor)
         */
        function setupAudioChain(context) {
            // 0. Generate Impulse Response (needs to be done only once per context type)
            impulseResponseBuffer = createImpulseResponse(context);

            // 1. Dynamics Compressor
            const currentCompressor = context.createDynamicsCompressor();
            currentCompressor.threshold.setValueAtTime(parseFloat(compressionThresholdInput.value), context.currentTime); 
            currentCompressor.knee.setValueAtTime(30, context.currentTime);
            currentCompressor.ratio.setValueAtTime(12, context.currentTime);
            currentCompressor.attack.setValueAtTime(0.003, context.currentTime);
            currentCompressor.release.setValueAtTime(0.25, context.currentTime);
            
            // 2. Biquad Filter (Low-Shelf for Warmth/Bass Boost)
            const currentLowShelfFilter = context.createBiquadFilter();
            currentLowShelfFilter.type = "lowshelf";
            currentLowShelfFilter.frequency.setValueAtTime(250, context.currentTime); 
            currentLowShelfFilter.gain.setValueAtTime(parseFloat(warmthBoostInput.value), context.currentTime); 

            // 3. Biquad Filter (High-Shelf for Clarity/Treble Boost)
            const currentHighShelfFilter = context.createBiquadFilter();
            currentHighShelfFilter.type = "highshelf";
            currentHighShelfFilter.frequency.setValueAtTime(3000, context.currentTime); 
            currentHighShelfFilter.gain.setValueAtTime(parseFloat(clarityBoostInput.value), context.currentTime); 

            // 4. NEW: Convolver (Reverb Processor)
            const currentConvolver = context.createConvolver();
            currentConvolver.buffer = impulseResponseBuffer;
            
            // 5. NEW: Dry/Wet Mix Gains
            const currentDryGain = context.createGain();
            const currentWetGain = context.createGain();
            
            // Set initial mix based on UI slider (reverbDepthInput)
            const reverbMixPercent = parseFloat(reverbDepthInput.value) / 100;
            currentDryGain.gain.setValueAtTime(1.0 - reverbMixPercent, context.currentTime);
            currentWetGain.gain.setValueAtTime(reverbMixPercent, context.currentTime);

            // 6. Master Gain
            const currentMasterGain = context.createGain();
            currentMasterGain.gain.setValueAtTime(parseFloat(masterGainInput.value), context.currentTime);

            // --- Connections ---
            currentCompressor.connect(currentLowShelfFilter);
            currentLowShelfFilter.connect(currentHighShelfFilter);

            // Split path AFTER EQ (HighShelf)
            currentHighShelfFilter.connect(currentDryGain); // DRY path
            currentHighShelfFilter.connect(currentConvolver); // WET path input
            
            // Connect WET path output
            currentConvolver.connect(currentWetGain);

            // Mix Dry and Wet into Master Gain
            currentDryGain.connect(currentMasterGain);
            currentWetGain.connect(currentMasterGain);

            // Connect Master Gain to Destination (only if it's the main AudioContext)
            if (context instanceof AudioContext) {
                 currentMasterGain.connect(context.destination);
                 
                 // Store references for real-time adjustments
                 compressor = currentCompressor;
                 lowShelfFilter = currentLowShelfFilter;
                 highShelfFilter = currentHighShelfFilter;
                 dryGain = currentDryGain; 
                 wetGain = currentWetGain;
                 masterGain = currentMasterGain;
                 convolver = currentConvolver; // Store convolver reference (though its buffer is static)

            } else {
                 // For OfflineAudioContext, connect to the destination
                 currentMasterGain.connect(context.destination);
            }
            
            controlsDiv.classList.remove('opacity-50', 'pointer-events-none');
            return currentCompressor; // Return the start of the chain
        }


        /**
         * Loads the selected file, decodes it, and enables the play/download buttons.
         * @param {File} file The audio file selected by the user.
         */
        function loadAndDecodeFile(file) {
            stopPlayback(); // Stop any currently playing audio
            
            if (!audioContext) {
                // Initialize the main context for playback preview
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                setupAudioChain(audioContext);
            }

            uploadedFileName = file.name.replace(/\.[^/.]+$/, "") || 'enhanced_audio'; // Save file name without extension

            const reader = new FileReader();

            reader.onloadstart = () => {
                statusBox.textContent = 'Loading file...';
                statusBox.classList.remove('bg-red-100', 'text-red-700', 'bg-green-100', 'text-green-700', 'bg-blue-100', 'text-blue-700');
                statusBox.classList.add('bg-gray-100', 'text-gray-700');
                toggleButton.disabled = true;
                downloadButton.disabled = true;
                toggleButton.textContent = "Processing...";
                downloadButton.textContent = "Download WAV";
                fileNameDisplay.classList.add('hidden');
            };

            reader.onload = async (e) => {
                try {
                    const arrayBuffer = e.target.result;
                    statusBox.textContent = 'Decoding audio data...';

                    // Decode the audio data asynchronously
                    audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    
                    toggleButton.disabled = false;
                    downloadButton.disabled = false;
                    toggleButton.textContent = "Play Enhanced Audio";
                    toggleButton.classList.remove('opacity-50', 'cursor-not-allowed', 'bg-red-500', 'hover:bg-red-600', 'focus:ring-red-300');
                    toggleButton.classList.add('bg-amber-500', 'hover:bg-amber-600', 'focus:ring-amber-300');
                    downloadButton.classList.remove('opacity-50', 'cursor-not-allowed');
                    
                    statusBox.textContent = `File ready: ${file.name}. Click 'Play' or 'Download'.`;
                    statusBox.classList.remove('bg-gray-100', 'text-gray-700');
                    statusBox.classList.add('bg-green-100', 'text-green-700');
                    fileNameDisplay.textContent = `Duration: ${audioBuffer.duration.toFixed(2)}s`;
                    fileNameDisplay.classList.remove('hidden');

                } catch (error) {
                    console.error('Error decoding audio data:', error);
                    audioBuffer = null;
                    statusBox.textContent = 'Error: Could not decode audio file. Make sure it is a valid format.';
                    statusBox.classList.remove('bg-green-100', 'text-green-700');
                    statusBox.classList.add('bg-red-100', 'text-red-700');
                    toggleButton.disabled = true;
                    downloadButton.disabled = true;
                    toggleButton.textContent = "Processing Error";
                }
            };

            reader.readAsArrayBuffer(file);
        }

        /**
         * Starts playing the enhanced audio from the buffer.
         */
        async function startPlayback() {
            if (!audioBuffer) {
                console.error("No audio buffer loaded.");
                return;
            }

            if (audioContext.state === 'suspended') {
                await audioContext.resume();
            }
            
            // A source node can only be played once, so we create a new one every time.
            sourceNode = audioContext.createBufferSource();
            sourceNode.buffer = audioBuffer;
            
            // Connect the source to the first enhancement node (Compressor)
            sourceNode.connect(compressor);

            sourceNode.onended = () => {
                if(isPlaying) {
                   // Only trigger stop if it ended naturally, not by a user stop command
                   stopPlayback(true); 
                }
            };
            
            // Start the audio
            startTime = audioContext.currentTime - elapsed;
            sourceNode.start(0, elapsed);
            
            isPlaying = true;
            toggleButton.textContent = "Stop Playback";
            toggleButton.classList.remove('bg-amber-500', 'hover:bg-amber-600', 'focus:ring-amber-300');
            toggleButton.classList.add('bg-red-500', 'hover:bg-red-600', 'focus:ring-red-300');
            statusBox.textContent = 'Playing enhanced audio... Adjust controls in real-time.';
            statusBox.classList.remove('bg-green-100', 'text-green-700');
            statusBox.classList.add('bg-blue-100', 'text-blue-700');
            downloadButton.disabled = true; // Disable download during playback
        }

        /**
         * Stops the audio playback and resets the button state.
         * @param {boolean} endedNaturally If true, it means the audio buffer finished playing.
         */
        function stopPlayback(endedNaturally = false) {
            if (isPlaying && sourceNode) {
                // Disconnect source before stopping to prevent potential errors
                sourceNode.disconnect(); 
                sourceNode.stop(0);
                sourceNode = null;
                elapsed = 0; // Reset time for next play
            }

            isPlaying = false;
            
            toggleButton.textContent = "Play Enhanced Audio";
            toggleButton.classList.remove('bg-red-500', 'hover:bg-red-600', 'focus:ring-red-300');
            toggleButton.classList.add('bg-amber-500', 'hover:bg-amber-600', 'focus:ring-amber-300');
            
            if (audioBuffer) {
                 statusBox.textContent = endedNaturally 
                    ? `Playback finished. Press 'Play' or 'Download'.`
                    : `Playback stopped. Ready to play or download.`;
                 statusBox.classList.remove('bg-blue-100', 'text-blue-700');
                 statusBox.classList.add('bg-green-100', 'text-green-700');
                 downloadButton.disabled = false; // Re-enable download
            }
        }

        /**
         * Converts AudioBuffer data into a WAV file format (ArrayBuffer).
         * @param {AudioBuffer} abuffer The buffer containing the raw audio data.
         * @returns {ArrayBuffer} The binary data for the WAV file.
         */
        function bufferToWave(abuffer) {
            const numOfChan = abuffer.numberOfChannels;
            const len = abuffer.length;
            const rate = abuffer.sampleRate;
            
            // 44 bytes for the header + (length * num_channels * 2 bytes/sample for 16-bit PCM)
            const buffer = new ArrayBuffer(44 + len * numOfChan * 2); 
            const view = new DataView(buffer);
            const channels = [];
            let offset = 0, pos = 0;

            // RIFF header
            function setUint32(data) { view.setUint32(offset, data, true); offset += 4; }
            function setUint16(data) { view.setUint16(offset, data, true); offset += 2; }
            
            setUint32(0x46464952); // "RIFF"
            setUint32(buffer.byteLength - 8); // File length - 8
            setUint32(0x45564157); // "WAVE"

            // FMT chunk
            setUint32(0x20746d66); // "fmt " chunk identifier
            setUint32(16); // chunk length (16 for PCM)
            setUint16(1); // 1 = PCM (uncompressed)
            setUint16(numOfChan);
            setUint32(rate); // Sample rate
            setUint32(rate * numOfChan * 2); // Byte rate (SampleRate * NumChannels * 2)
            setUint16(numOfChan * 2); // Block align (NumChannels * 2)
            setUint16(16); // Bits per sample (16 bit)

            // DATA chunk
            setUint32(0x61746164); // "data" chunk identifier
            setUint32(len * numOfChan * 2); // Data length

            // Get samples
            for (let i = 0; i < numOfChan; i++) {
                channels.push(abuffer.getChannelData(i));
            }

            // Interleave and write samples as 16-bit signed integers
            while (pos < len) {
                for (let i = 0; i < numOfChan; i++) {
                    let sample = channels[i][pos];
                    // Scale and convert to 16-bit signed integer
                    sample = Math.max(-1, Math.min(1, sample)); // Clamp to [-1, 1]
                    sample = (sample < 0 ? sample * 0x8000 : sample * 0x7FFF);
                    view.setInt16(offset, sample, true); // true = little-endian
                    offset += 2;
                }
                pos++;
            }

            return buffer;
        }

        /**
         * Renders the enhanced audio offline and triggers the download.
         */
        async function renderAndDownload() {
            if (!audioBuffer) {
                statusBox.textContent = 'Please select and load an audio file first.';
                statusBox.classList.remove('bg-green-100', 'text-green-700', 'bg-blue-100', 'text-blue-700');
                statusBox.classList.add('bg-red-100', 'text-red-700');
                return;
            }

            stopPlayback();
            downloadButton.disabled = true;
            toggleButton.disabled = true;
            downloadButton.textContent = "Rendering...";
            statusBox.textContent = 'Processing audio offline... This may take a moment.';
            statusBox.classList.remove('bg-green-100', 'text-green-700');
            statusBox.classList.add('bg-blue-100', 'text-blue-700');

            try {
                // 1. Create Offline Audio Context
                const offlineContext = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(
                    audioBuffer.numberOfChannels,
                    audioBuffer.length,
                    audioBuffer.sampleRate
                );

                // 2. Set up the enhancement chain on the offline context
                const inputNode = setupAudioChain(offlineContext);

                // 3. Create Source Node
                const offlineSource = offlineContext.createBufferSource();
                offlineSource.buffer = audioBuffer;
                offlineSource.connect(inputNode);

                // 4. Start rendering
                offlineSource.start(0);
                const processedBuffer = await offlineContext.startRendering();

                // 5. Convert rendered AudioBuffer to WAV ArrayBuffer
                const wavData = bufferToWave(processedBuffer);

                // 6. Create Blob and trigger download
                const blob = new Blob([wavData], { type: 'audio/wav' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = `${uploadedFileName}_enhanced.wav`;
                document.body.appendChild(a);
                a.click();
                
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);

                statusBox.textContent = 'Download complete! File saved as enhanced WAV.';
                statusBox.classList.remove('bg-blue-100', 'text-blue-700');
                statusBox.classList.add('bg-green-100', 'text-green-700');

            } catch (error) {
                console.error('Offline Rendering or Download failed:', error);
                statusBox.textContent = 'Download Error: Failed to render or create the file.';
                statusBox.classList.remove('bg-blue-100', 'text-blue-700');
                statusBox.classList.add('bg-red-100', 'text-red-700');
            } finally {
                downloadButton.disabled = false;
                toggleButton.disabled = false;
                downloadButton.textContent = "Download WAV";
            }
        }

        // --- Event Listeners for Controls and Toggle ---

        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                loadAndDecodeFile(file);
            } else {
                audioBuffer = null;
                toggleButton.disabled = true;
                downloadButton.disabled = true;
                toggleButton.classList.add('opacity-50', 'cursor-not-allowed');
                downloadButton.classList.add('opacity-50', 'cursor-not-allowed');
                statusBox.textContent = 'Awaiting file selection...';
                fileNameDisplay.classList.add('hidden');
            }
        });


        toggleButton.addEventListener('click', () => {
            if (isPlaying) {
                stopPlayback();
            } else {
                startPlayback();
            }
        });
        
        // Listener for Download
        downloadButton.addEventListener('click', renderAndDownload);

        // --- Real-Time Control Updates ---
        
        // NEW: Reverb Depth Listener
        reverbDepthInput.addEventListener('input', () => {
            const percent = parseInt(reverbDepthInput.value, 10);
            reverbDepthValueSpan.textContent = `${percent}%`;
            
            if (dryGain && wetGain) {
                const reverbMix = percent / 100;
                // Set the gains for smooth fading
                dryGain.gain.setValueAtTime(1.0 - reverbMix, audioContext.currentTime);
                wetGain.gain.setValueAtTime(reverbMix, audioContext.currentTime);
            }
        });


        masterGainInput.addEventListener('input', () => {
            const gainValue = parseFloat(masterGainInput.value);
            masterGainValueSpan.textContent = gainValue.toFixed(2);
            if (masterGain) {
                masterGain.gain.setValueAtTime(gainValue, audioContext.currentTime);
            }
        });

        clarityBoostInput.addEventListener('input', () => {
            const gainValue = parseFloat(clarityBoostInput.value);
            clarityBoostValueSpan.textContent = `${gainValue.toFixed(1)} dB`;
            if (highShelfFilter) {
                highShelfFilter.gain.setValueAtTime(gainValue, audioContext.currentTime);
            }
        });
        
        warmthBoostInput.addEventListener('input', () => {
            const gainValue = parseFloat(warmthBoostInput.value);
            warmthBoostValueSpan.textContent = `${gainValue.toFixed(1)} dB`;
            if (lowShelfFilter) {
                lowShelfFilter.gain.setValueAtTime(gainValue, audioContext.currentTime);
            }
        });


        compressionThresholdInput.addEventListener('input', () => {
            const thresholdValue = parseFloat(compressionThresholdInput.value);
            compressionThresholdValueSpan.textContent = `${thresholdValue.toFixed(1)} dB`;
            if (compressor) {
                compressor.threshold.setValueAtTime(thresholdValue, audioContext.currentTime);
            }
        });
        
        // The main AudioContext and chain will be initialized lazily in loadAndDecodeFile for cleaner startup.

    </script>
</body>
</html>
